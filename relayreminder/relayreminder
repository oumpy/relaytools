#!/usr/bin/env python3
#
# RelayReminder
#
# @2023 AtamaokaC
# Python Party of Osaka University Medical School, Japan
#
# Lisence: GNU General Publice Lisence v3
#

from mattermostdriver import Driver
from datetime import datetime, date, timedelta
import argparse
from typing import List, Dict, Optional, Union, Any
import warnings
from bisect import bisect_left, bisect_right

BASE_TIME = datetime(1,1,3)
BASE_DATE = BASE_TIME.date() # Monday

def get_week_number(target_date: Union[datetime, date]) -> int:
    if isinstance(target_date, datetime):
        target_date = target_date.date()

    delta_days = (target_date - BASE_DATE).days
    week_number = delta_days // 7

    return week_number

class MattermostChannel:
    def __init__(self, driver_params: Dict, team_name: str, channel_name: str, after_time: datetime = datetime.fromtimestamp(0), stdout_mode: bool = False):
        self.mm_driver = Driver(driver_params)
        self.mm_driver.login()
        self.team_name = team_name
        self.channel_name = channel_name
        self.channel_id = self._get_channel_id()
        self.members = self.fetch_members()
        self.usernames = self.fetch_usernames()
        self.after_time = after_time
        self.all_posts = {'order': [], 'posts': {}}
        self.stdout_mode = stdout_mode

    def _get_channel_id(self) -> str:
        channel = self.mm_driver.channels.get_channel_by_name_and_team_name(self.team_name, self.channel_name)
        return channel['id']

    def fetch_members(self) -> List[str]:
        members = self.mm_driver.channels.get_channel_members(self.channel_id)
        return [member['user_id'] for member in members]

    def fetch_usernames(self) -> Dict[str, str]:
        """
        Fetch usernames based on member user_ids.
        
        Returns:
            A dictionary where keys are user_ids and values are corresponding usernames.
        """
        usernames = {}
        for user_id in self.members:
            user = self.mm_driver.users.get_user(user_id)
            usernames[user_id] = user['username']
        return usernames

    def get_username_by_id(self, user_id: str) -> Optional[str]:
        """
        Get the username for a given user_id using the self.usernames dictionary.
        
        Returns:
            Username corresponding to the user_id or None if not found.
        """
        return self.usernames.get(user_id, None)

    def fetch_posts(self) -> Dict:
        posts = self.mm_driver.posts.get_posts_for_channel(self.channel_id, params={'since': int(self.after_time.timestamp() * 1000)})
        self.all_posts = posts  # Update the all_posts property
        return posts

    def fetch_last_post_dates(self, 
                              user_ids: Optional[List[str]] = None,
                              priority_filter: Optional[str] = None,
                              is_thread_head: Optional[bool] = None,
                              ignore_deleted_posts: Optional[bool] = True) -> Dict[str, datetime]:

        if user_ids is None:
            user_ids = self.members

        last_post_dates = dict.fromkeys(user_ids, BASE_TIME)

        if priority_filter:
            priority_filter = priority_filter.lower()

        for post in self.all_posts['posts'].values():
            user_id = post['user_id']
            create_at = datetime.fromtimestamp(post['create_at'] / 1000)
            root_id = post.get('root_id', '')
            priority = post['metadata'].get('priority', {}).get('priority', 'standard').lower()

            # Skip deleted post (optional)
            if ignore_deleted_posts and post['delete_at'] != 0:
                continue

            if user_id in user_ids:
                if (priority_filter is None or priority == priority_filter) and \
                   (is_thread_head is None or bool(root_id) == is_thread_head):
                    if user_id not in last_post_dates or create_at > last_post_dates[user_id]:
                        last_post_dates[user_id] = create_at

        return last_post_dates

    def send_post(self, message: str, props: Optional[Dict] = None, root_id: Optional[str] = None) -> Dict:
        payload = {
            'channel_id': self.channel_id,
            'message': message,
        }

        if props:
            payload['props'] = props

        if root_id:
            payload['root_id'] = root_id
            if not root_id in self.all_posts['posts']:
                warnings.warn(f"Given root_id '{root_id}' does not exist in fetched posts. Posting directly to the channel.")

        if self.stdout_mode:
            print(payload)
        else:
            self.mm_driver.posts.create_post(payload)
        
        return payload


    def filter_posts_by_criteria(self, criteria: Dict[str, Any], posts: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        if posts is None:
            posts = self.all_posts['posts']

        def match_criteria(data: Dict[str, Any], criteria: Dict[str, Any]) -> bool:
            for key, value in criteria.items():
                if key not in data:
                    return False
                if isinstance(value, dict):
                    if not match_criteria(data[key], value):
                        return False
                elif data[key] != value:
                    return False
            return True

        filtered_posts = {post_id: post for post_id, post in posts.items() if match_criteria(post, criteria)}
        return filtered_posts

def load_tsv_data(file_path: str) -> Dict[int, str]:
    data = {}
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            # Skip comments and empty lines
            if not line or line.startswith('#'):
                continue

            parts = line.split('\t')
            if len(parts) != 2:
                continue

            # Try converting the first column to an integer (week number)
            try:
                week_number = int(parts[0])
            except ValueError:
                continue

            # Skip if the message is empty
            if not parts[1]:
                continue

            data[week_number] = parts[1]
    return data

def get_start_of_week_n_weeks_ago(n: int) -> datetime:
    today = datetime.now().date()  # Get today
    start_of_this_week = today - timedelta(days=today.weekday())  # Get Monday of this week
    target_date = start_of_this_week - timedelta(weeks=n)  # Get Monday n-weeks ago
    return datetime(target_date.year, target_date.month, target_date.day)

def parse_arguments() -> argparse.Namespace:
    """
    Parse command line arguments and return the Namespace object.
    """
    parser = argparse.ArgumentParser(description="RelayReminder: the 3rd-generation bot-system for the relay-posts.")
    parser.add_argument("--url", type=str, required=True, help="Mattermost URL")
    parser.add_argument("--scheme", type=str, default="https", help="Mattermost URL Scheme")
    parser.add_argument("--port", type=int, default=443, help="Mattermost Port")
    parser.add_argument("--token", type=str, required=True, help="Access Token")
    parser.add_argument("--team", type=str, required=True, help="Team name")
    parser.add_argument("--channel", type=str, required=True, help="Channel name")
    parser.add_argument("--all-users", action="store_true", help="Notify all users including ones with no posts")
    parser.add_argument("--message-file", type=str, required=True, help="Path to the TSV file containing week intervals & reminder messages.")
    parser.add_argument("--stdout-mode", action="store_true", help="Post to stdout, instead of the Mattermost channel.")
    return parser.parse_args()

def main(args: argparse.Namespace):
    driver_params = {
        "url": args.url,
        "scheme": args.scheme,
        "port": args.port,
        "token": args.token
    }
    # Load message data
    message_data = load_tsv_data(args.message_file)
    message_passed_weeks_list = sorted(message_data.keys())
    max_week_limit = message_passed_weeks_list[-1]

    mm_channel = MattermostChannel(
        driver_params, args.team, args.channel,
        after_time = get_start_of_week_n_weeks_ago(max_week_limit),
        stdout_mode = args.stdout_mode,
    )    
    # Fetch all posts
    mm_channel.fetch_posts()
    # Fetch last post dates for all members
    last_post_dates = mm_channel.fetch_last_post_dates(priority_filter="standard", is_thread_head=True)

    # Convert dates to week numbers
    last_post_weeks = {user_id: get_week_number(date) for user_id, date in last_post_dates.items()}
    current_week_number = get_week_number(datetime.now())

    # Find users and message based on last post week number
    users_to_notify = {}
    for user_id, week in last_post_weeks.items():
        if week not in users_to_notify:
            users_to_notify[week] = []
        users_to_notify[week].append(user_id)

    # Post messages
    for week, user_ids in users_to_notify.items():
        # Skip users with no posts unless specified
        if week == 0 and not args.all_users:
            continue

        passed_weeks = current_week_number - week
        criteria = {
            "props": {
                "last_post_week": week,
            }
        }
        matching_posts = mm_channel.filter_posts_by_criteria(criteria)
        # Find the matching post with maximum weeks passed
        if matching_posts:
            last_passed_weeks = max(post['props']['passed_weeks'] for post in matching_posts.values())
        else:
            last_passed_weeks = -1

        passed_weeks_k = bisect_right(message_passed_weeks_list, passed_weeks)
        if passed_weeks_k == 0:
            continue
        passed_weeks_to_post = message_passed_weeks_list[passed_weeks_k-1]

        if passed_weeks_to_post > last_passed_weeks:
            message_start = message_data[passed_weeks_to_post].format(passed_weeks)
            sorted_user_ids = sorted(user_ids, key=lambda uid: last_post_dates[uid])
            mentions = '\n'.join([f'@{mm_channel.get_username_by_id(user_id)}' for user_id in sorted_user_ids])

            message = f"{message_start}\n\n{mentions}"

            if last_passed_weeks >= 0:
                root_id = matching_posts[0]['root_id']  # Getting the first matching post's ID as root
                if root_id == '':
                    root_id = matching_posts[0]['id']
            else:
                root_id = None

            mm_channel.send_post(
                message,
                props={
                    "last_post_week": week,
                    "passed_weeks": passed_weeks,
                },
                root_id=root_id,
            )

if __name__ == "__main__":
    args = parse_arguments()
    main(args)

if False:
    parser = argparse.ArgumentParser(description="RelayReminder: the 3rd-generation bot-system for the relay-posts.")
    parser.add_argument("--url", type=str, required=True, help="Mattermost URL")
    parser.add_argument("--scheme", type=str, default="https", help="Mattermost URL Scheme")
    parser.add_argument("--port", type=int, default=443, help="Mattermost Port")
    parser.add_argument("--token", type=str, required=True, help="Access Token")
    parser.add_argument("--team", type=str, required=True, help="Team name")
    parser.add_argument("--channel", type=str, required=True, help="Channel name")

    args = parser.parse_args()

    mm_channel = MattermostChannel(
        {
            "url": args.url,
            "scheme": args.scheme,
            "port": args.port,
            "token": args.token,
        },
        args.team, args.channel)

    now = datetime.now()
    start_time = now - timedelta(days=7)

    user_ids = mm_channel.fetch_members()
    print(f"All user IDs: {user_ids}")

    all_posts = mm_channel.fetch_posts()
    print(f"All posts since start time: {all_posts}")

    last_post_dates = mm_channel.fetch_last_post_dates(user_ids)
    print(f"Last post dates for each user: {last_post_dates}")
