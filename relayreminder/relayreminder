#!/usr/bin/env python3
#
# RelayReminder
#
# @2023 AtamaokaC
# Python Party of Osaka University Medical School, Japan
#
# Lisence: GNU General Publice Lisence v3
#

from mattermostdriver import Driver
from datetime import datetime, date, timedelta
import argparse
from typing import List, Dict, Optional, Union, Any
import warnings

BASE_TIME = datetime(1,1,3)
BASE_DATE = BASE_TIME.date() # Monday

def get_week_number(target_date: Union[datetime, date]) -> int:
    if isinstance(target_date, datetime):
        target_date = target_date.date()

    delta_days = (target_date - BASE_DATE).days
    week_number = delta_days // 7

    return week_number

class MattermostChannel:
    def __init__(self, driver_params: Dict, team_name: str, channel_name: str, after_time: datetime = datetime.fromtimestamp(0)):
        self.mm_driver = Driver(driver_params)
        self.mm_driver.login()
        self.team_name = team_name
        self.channel_name = channel_name
        self.channel_id = self._get_channel_id()
        self.members = self.fetch_members()
        self.after_time = after_time
        self.all_posts = {'order': [], 'posts': {}}

    def _get_channel_id(self) -> str:
        channel = self.mm_driver.channels.get_channel_by_name_and_team_name(self.team_name, self.channel_name)
        return channel['id']

    def fetch_members(self) -> List[str]:
        members = self.mm_driver.channels.get_channel_members(self.channel_id)
        return [member['user_id'] for member in members]

    def fetch_posts(self) -> Dict:
        posts = self.mm_driver.posts.get_posts_for_channel(self.channel_id, params={'since': int(self.after_time.timestamp() * 1000)})
        self.all_posts = posts  # Update the all_posts property
        return posts

    def fetch_last_post_dates(self, 
                              user_ids: Optional[List[str]] = None,
                              priority_filter: Optional[str] = None,
                              is_thread_head: Optional[bool] = None,
                              ignore_deleted_posts: Optional[bool] = True) -> Dict[str, datetime]:

        if user_ids is None:
            user_ids = self.members

        last_post_dates = dict.fromkeys(user_ids, BASE_TIME)

        if priority_filter:
            priority_filter = priority_filter.lower()

        for post in self.all_posts['posts'].values():
            user_id = post['user_id']
            create_at = datetime.fromtimestamp(post['create_at'] / 1000)
            root_id = post.get('root_id', '')
            priority = post['metadata'].get('priority', {}).get('priority', 'standard').lower()

            # Skip deleted post (optional)
            if ignore_deleted_posts and post['delete_at'] != 0:
                continue

            if user_id in user_ids:
                if (priority_filter is None or priority == priority_filter) and \
                   (is_thread_head is None or bool(root_id) == is_thread_head):
                    if user_id not in last_post_dates or create_at > last_post_dates[user_id]:
                        last_post_dates[user_id] = create_at

        return last_post_dates

    def send_post(self, message: str, props: Optional[Dict] = None, root_id: Optional[str] = None):
        payload = {
            'channel_id': self.channel_id,
            'message': message,
        }

        if props:
            payload['props'] = props

        if root_id:
            if root_id in self.all_posts['posts']:
                payload['root_id'] = root_id
            else:
                warnings.warn(f"Given root_id '{root_id}' does not exist in fetched posts. Posting directly to the channel.")

        self.mm_driver.posts.create_post(payload)

    def filter_posts_by_criteria(self, criteria: Dict[str, Any], posts: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        if posts is None:
            posts = self.all_posts['posts']

        def match_criteria(data: Dict[str, Any], criteria: Dict[str, Any]) -> bool:
            for key, value in criteria.items():
                if key not in data:
                    return False
                if isinstance(value, dict):
                    if not match_criteria(data[key], value):
                        return False
                elif data[key] != value:
                    return False
            return True

        filtered_posts = {post_id: post for post_id, post in posts.items() if match_criteria(post, criteria)}
        return filtered_posts


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="RelayReminder: the 3rd-generation bot-system for the relay-posts.")
    parser.add_argument("--url", type=str, required=True, help="Mattermost URL")
    parser.add_argument("--scheme", type=str, default="https", help="Mattermost URL Scheme")
    parser.add_argument("--port", type=int, default=443, help="Mattermost Port")
    parser.add_argument("--token", type=str, required=True, help="Access Token")
    parser.add_argument("--team", type=str, required=True, help="Team name")
    parser.add_argument("--channel", type=str, required=True, help="Channel name")

    args = parser.parse_args()

    mm_channel = MattermostChannel(
        {
            "url": args.url,
            "scheme": args.scheme,
            "port": args.port,
            "token": args.token,
        },
        args.team, args.channel)

    now = datetime.now()
    start_time = now - timedelta(days=7)

    user_ids = mm_channel.fetch_members()
    print(f"All user IDs: {user_ids}")

    all_posts = mm_channel.fetch_posts()
    print(f"All posts since start time: {all_posts}")

    last_post_dates = mm_channel.fetch_last_post_dates(user_ids)
    print(f"Last post dates for each user: {last_post_dates}")
