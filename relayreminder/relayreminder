#!/usr/bin/env python3
#
# RelayReminder
#
# @2023 AtamaokaC
# Python Party of Osaka University Medical School, Japan
#
# Lisence: GNU General Publice Lisence v3
#

from mattermostdriver import Driver
from datetime import datetime, date, timedelta
import argparse
from typing import List, Dict, Optional, Union, Any
import warnings
import yaml

BASE_TIME = datetime(1,1,3)
BASE_DATE = BASE_TIME.date() # Monday

def get_week_number(target_date: Union[datetime, date]) -> int:
    if isinstance(target_date, datetime):
        target_date = target_date.date()

    delta_days = (target_date - BASE_DATE).days
    week_number = delta_days // 7

    return week_number

class MattermostChannel:
    def __init__(self, driver_params: Dict, team_name: str, channel_name: str, after_time: datetime = datetime.fromtimestamp(0)):
        self.mm_driver = Driver(driver_params)
        self.mm_driver.login()
        self.team_name = team_name
        self.channel_name = channel_name
        self.channel_id = self._get_channel_id()
        self.members = self.fetch_members()
        self.usernames = self.fetch_usernames()
        self.after_time = after_time
        self.all_posts = {'order': [], 'posts': {}}

    def _get_channel_id(self) -> str:
        channel = self.mm_driver.channels.get_channel_by_name_and_team_name(self.team_name, self.channel_name)
        return channel['id']

    def fetch_members(self) -> List[str]:
        members = self.mm_driver.channels.get_channel_members(self.channel_id)
        return [member['user_id'] for member in members]

    def fetch_usernames(self) -> Dict[str, str]:
        """
        Fetch usernames based on member user_ids.
        
        Returns:
            A dictionary where keys are user_ids and values are corresponding usernames.
        """
        usernames = {}
        for user_id in self.members:
            user = self.mm_driver.users.get_user(user_id)
            usernames[user_id] = user['username']
        return usernames

    def get_username_by_id(self, user_id: str) -> Optional[str]:
        """
        Get the username for a given user_id using the self.usernames dictionary.
        
        Returns:
            Username corresponding to the user_id or None if not found.
        """
        return self.usernames.get(user_id, None)

    def fetch_posts(self) -> Dict:
        posts = self.mm_driver.posts.get_posts_for_channel(self.channel_id, params={'since': int(self.after_time.timestamp() * 1000)})
        self.all_posts = posts  # Update the all_posts property
        return posts

    def fetch_last_post_dates(self, 
                              user_ids: Optional[List[str]] = None,
                              priority_filter: Optional[str] = None,
                              is_thread_head: Optional[bool] = None,
                              ignore_deleted_posts: Optional[bool] = True) -> Dict[str, datetime]:

        if user_ids is None:
            user_ids = self.members

        last_post_dates = dict.fromkeys(user_ids, BASE_TIME)

        if priority_filter:
            priority_filter = priority_filter.lower()

        for post in self.all_posts['posts'].values():
            user_id = post['user_id']
            create_at = datetime.fromtimestamp(post['create_at'] / 1000)
            root_id = post.get('root_id', '')
            priority = post['metadata'].get('priority', {}).get('priority', 'standard').lower()

            # Skip deleted post (optional)
            if ignore_deleted_posts and post['delete_at'] != 0:
                continue

            if user_id in user_ids:
                if (priority_filter is None or priority == priority_filter) and \
                   (is_thread_head is None or bool(root_id) == is_thread_head):
                    if user_id not in last_post_dates or create_at > last_post_dates[user_id]:
                        last_post_dates[user_id] = create_at

        return last_post_dates

    def send_post(self, message: str, props: Optional[Dict] = None, root_id: Optional[str] = None):
        payload = {
            'channel_id': self.channel_id,
            'message': message,
        }

        if props:
            payload['props'] = props

        if root_id:
            if root_id in self.all_posts['posts']:
                payload['root_id'] = root_id
            else:
                warnings.warn(f"Given root_id '{root_id}' does not exist in fetched posts. Posting directly to the channel.")

        self.mm_driver.posts.create_post(payload)

    def filter_posts_by_criteria(self, criteria: Dict[str, Any], posts: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        if posts is None:
            posts = self.all_posts['posts']

        def match_criteria(data: Dict[str, Any], criteria: Dict[str, Any]) -> bool:
            for key, value in criteria.items():
                if key not in data:
                    return False
                if isinstance(value, dict):
                    if not match_criteria(data[key], value):
                        return False
                elif data[key] != value:
                    return False
            return True

        filtered_posts = {post_id: post for post_id, post in posts.items() if match_criteria(post, criteria)}
        return filtered_posts

def parse_arguments() -> argparse.Namespace:
    """
    Parse command line arguments and return the Namespace object.
    """
    parser = argparse.ArgumentParser(description="RelayReminder: the 3rd-generation bot-system for the relay-posts.")
    parser.add_argument("--url", type=str, required=True, help="Mattermost URL")
    parser.add_argument("--scheme", type=str, default="https", help="Mattermost URL Scheme")
    parser.add_argument("--port", type=int, default=443, help="Mattermost Port")
    parser.add_argument("--token", type=str, required=True, help="Access Token")
    parser.add_argument("--team", type=str, required=True, help="Team name")
    parser.add_argument("--channel", type=str, required=True, help="Channel name")
    parser.add_argument("--all-users", action="store_true", help="Notify all users including ones with no posts")
    parser.add_argument("--yaml-file", type=str, required=True, help="Path to the YAML file containing reminder messages and their week intervals.")
    return parser.parse_args()

def main(args: argparse.Namespace):
    driver_params = {
        "url": args.url,
        "scheme": args.scheme,
        "port": args.port,
        "token": args.token
    }
    mm_channel = MattermostChannel(driver_params, args.team, args.channel)
    
    # Fetch all posts
    mm_channel.fetch_posts()

    # Fetch last post dates for all members
    last_post_dates = mm_channel.fetch_last_post_dates(priority_filter="standard", is_thread_head=True)
    
    # Convert dates to week numbers
    last_post_weeks = {user_id: get_week_number(date) for user_id, date in last_post_dates.items()}
    current_week_number = get_week_number(datetime.now())

    # Load YAML data
    with open(args.yaml_file, "r") as file:
        yaml_data = yaml.safe_load(file)

    # Find users and message based on last post week number
    users_to_notify = {}
    for user_id, week in last_post_weeks.items():
        passed_weeks = current_week_number - week
        if passed_weeks in yaml_data:
            if week not in users_to_notify:
                users_to_notify[week] = []
            users_to_notify[week].append(user_id)

    # Post messages
    for week, user_ids in users_to_notify.items():
        # Skip users with no posts unless specified
        if week == 0 and not args.all_users:
            continue

        passed_weeks = current_week_number - week
        criteria = {
            "props": {
                "last_post_week": week,
                "passed_weeks": passed_weeks
            }
        }
        matching_posts = mm_channel.filter_posts_by_criteria(criteria)
        
        # Find the matching post with maximum weeks passed
        max_passed_weeks = max(post['props']['passed_weeks'] for post in matching_posts.values())
        max_week_limit = max(yaml_data.keys())

        message_start = yaml_data[passed_weeks].format(passed_weeks)
        sorted_user_ids = sorted(user_ids, key=lambda uid: last_post_dates[uid])
        mentions = '\n'.join([f'@{mm_channel.get_username_by_id(user_id)}' for user_id in sorted_user_ids])

        message = f"{message_start}\n\n{mentions}"

        if passed_weeks < max_passed_weeks and week + max_week_limit <= current_week_number:
            root_id = next(iter(matching_posts))  # Getting the first matching post's ID as root
            mm_channel.send_post(message, props=criteria['props'], root_id=root_id)
        else:
            mm_channel.send_post(message, props=criteria['props'])

if __name__ == "__main__":
    args = parse_arguments()
    main(args)

if False:
    parser = argparse.ArgumentParser(description="RelayReminder: the 3rd-generation bot-system for the relay-posts.")
    parser.add_argument("--url", type=str, required=True, help="Mattermost URL")
    parser.add_argument("--scheme", type=str, default="https", help="Mattermost URL Scheme")
    parser.add_argument("--port", type=int, default=443, help="Mattermost Port")
    parser.add_argument("--token", type=str, required=True, help="Access Token")
    parser.add_argument("--team", type=str, required=True, help="Team name")
    parser.add_argument("--channel", type=str, required=True, help="Channel name")

    args = parser.parse_args()

    mm_channel = MattermostChannel(
        {
            "url": args.url,
            "scheme": args.scheme,
            "port": args.port,
            "token": args.token,
        },
        args.team, args.channel)

    now = datetime.now()
    start_time = now - timedelta(days=7)

    user_ids = mm_channel.fetch_members()
    print(f"All user IDs: {user_ids}")

    all_posts = mm_channel.fetch_posts()
    print(f"All posts since start time: {all_posts}")

    last_post_dates = mm_channel.fetch_last_post_dates(user_ids)
    print(f"Last post dates for each user: {last_post_dates}")
